"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createCache = void 0;
const getMseNow = () => new Date().getTime();
const createCache = ({ seconds, defaultSecondsUntilExpiration: defaultSecondsUntilExpirationInput, } = {}) => {
    var _a;
    // resolve input alias
    const defaultSecondsUntilExpiration = (_a = defaultSecondsUntilExpirationInput !== null && defaultSecondsUntilExpirationInput !== void 0 ? defaultSecondsUntilExpirationInput : seconds) !== null && _a !== void 0 ? _a : 5 * 60;
    // initialize a fresh in-memory cache object
    const cache = {};
    // define how to set an item into the cache
    const set = (key, value, { secondsUntilExpiration = defaultSecondsUntilExpiration, } = {}) => {
        // handle cache invalidation
        if (value === undefined) {
            delete cache[key];
            return;
        }
        // handle setting
        const expiresAtMse = getMseNow() + secondsUntilExpiration * 1000;
        cache[key] = { value, expiresAtMse };
    };
    // define how to get an item from the cache
    const get = (key) => {
        const cacheContent = cache[key];
        if (!cacheContent)
            return undefined; // if not in cache, then undefined
        if (cacheContent.expiresAtMse < getMseNow())
            return undefined; // if already expired, then undefined
        return cacheContent.value; // otherwise, its in the cache and not expired, so return the value
    };
    // define how to grab all valid keys
    const keys = () => Object.entries(cache)
        .filter(([_, value]) => value.expiresAtMse > getMseNow())
        .map(([key]) => key);
    // return the api
    return { set, get, keys };
};
exports.createCache = createCache;
//# sourceMappingURL=cache.js.map